import 'package:supabase_flutter/supabase_flutter.dart';
import 'data_models.dart';

/// Helper to manage persistent storage of documents in Supabase.
/// Documents are stored in a `documents` table with the following schema:
/// - id (bigint, primary key)
/// - course_title (text) - the course name
/// - file_name (text) - the uploaded file name
/// - file_url (text) - the public or signed URL to the file
/// - uploaded_by (text) - user id or email of the uploader
/// - uploaded_at (timestamp) - when the file was uploaded
/// - created_at (timestamp) - auto-generated by Supabase
class DocumentRetrievalHelper {
  static final supabase = Supabase.instance.client;
  static const tableName = 'documents';

  /// Fetch all documents for a specific course.
  /// Returns a list of CourseDocument objects.
  static Future<List<CourseDocument>> fetchDocumentsForCourse(String courseTitle) async {
    try {
      final response = await supabase
          .from(tableName)
          .select()
          .eq('course_title', courseTitle)
          .order('uploaded_at', ascending: false);

      final docs = (response as List<dynamic>).map((row) {
        return CourseDocument(
          name: row['file_name'] as String,
          url: row['file_url'] as String,
          uploadedBy: row['uploaded_by'] as String,
          uploadedAt: DateTime.parse(row['uploaded_at'] as String),
        );
      }).toList();

      return docs;
    } catch (e) {
      print('Error fetching documents for course $courseTitle: $e');
      return [];
    }
  }

  /// Save a newly uploaded document to the documents table.
  static Future<bool> saveDocument({
    required String courseTitle,
    required String fileName,
    required String fileUrl,
    required String uploadedBy,
    DateTime? uploadedAt,
  }) async {
    try {
      await supabase.from(tableName).insert({
        'course_title': courseTitle,
        'file_name': fileName,
        'file_url': fileUrl,
        'uploaded_by': uploadedBy,
        'uploaded_at': (uploadedAt ?? DateTime.now()).toIso8601String(),
      });
      return true;
    } catch (e) {
      print('Error saving document: $e');
      return false;
    }
  }

  /// Delete a document from the table and optionally from Supabase Storage.
  static Future<bool> deleteDocument({
    required String courseTitle,
    required String fileName,
    required String fileUrl,
    bool deleteFromStorage = true,
  }) async {
    try {
      // Delete from documents table
      await supabase
          .from(tableName)
          .delete()
          .eq('course_title', courseTitle)
          .eq('file_name', fileName);

      // Optionally delete from storage
      if (deleteFromStorage) {
        try {
          // Extract the path from the URL
          // URL format: https://projectid.supabase.co/storage/v1/object/public/bucket/path/to/file
          final uri = Uri.parse(fileUrl);
          final pathSegments = uri.pathSegments;
          
          // Find the bucket name and path
          int objectIndex = pathSegments.indexOf('object');
          if (objectIndex != -1 && objectIndex + 1 < pathSegments.length) {
            // Skip 'public' or 'authenticated' and get bucket name
            int bucketIndex = objectIndex + 2;
            if (bucketIndex < pathSegments.length) {
              final bucketName = pathSegments[bucketIndex];
              final filePath = pathSegments.sublist(bucketIndex + 1).join('/');
              
              if (filePath.isNotEmpty) {
                await supabase.storage
                    .from(bucketName)
                    .remove([filePath]);
              }
            }
          }
        } catch (e) {
          print('Warning: Could not delete file from storage: $e');
          // Don't fail the whole operation if storage deletion fails
        }
      }

      return true;
    } catch (e) {
      print('Error deleting document: $e');
      return false;
    }
  }

  /// Fetch all documents for a course and populate the Course object.
  static Future<void> populateDocumentsForCourse(Course course) async {
    try {
      final docs = await fetchDocumentsForCourse(course.title);
      course.documents = docs;
    } catch (e) {
      print('Error populating documents for course ${course.title}: $e');
    }
  }

  /// Fetch documents for all courses.
  static Future<Map<String, List<CourseDocument>>> fetchDocumentsForAllCourses(List<Course> courses) async {
    final Map<String, List<CourseDocument>> allDocs = {};
    
    try {
      for (final course in courses) {
        final docs = await fetchDocumentsForCourse(course.title);
        allDocs[course.title] = docs;
      }
    } catch (e) {
      print('Error fetching documents for all courses: $e');
    }
    
    return allDocs;
  }
}
